# Promises & Microtask Queue

Cum aliniem sa stea la rand aceasta functionalitate amânată daca avem un cod care foloseste utilitati din exterior cu si fara `Promise`? Sa presupunem ca avem urmatorul cod:

```jsx
function display(data) {
  console.log(data);
}

function printHello() {
  console.log('hello');
}

function blockFor300ms() {
  //blocheaza threadul JS timp de 3 milisecunde
}

setTimeout(printHello, 0);

const futureData = fetch('https://www.youtube.com/watch/vid2');
futureData.then(display);

blockFor300ms();

console.log('primul cod afisat')
```

1. in primele trei linii de cod, JS primeste instructiuni sa puna in memoria globala definitiile functiilor :
[Screencap 1]: https://i.imgur.com/skBhdgB.png "mem globala js"
![alt text][Screencap 1]
al doilea input 0 reprezinta cat timp va dura munca efectuata in background de browser, in cazul nostru browser-ul terminandu-si treaba aproape instant. Asta nu inseamna ca JS va fi gata sa puna printHello imediat pe call stack, insa functia se va pune aproape instant la coada in callback queue:
[Screencap 2]: https://i.imgur.com/n3EIQNU.png "context de executie Timer(printHello, 0)"
![alt text][Screencap 2]
3. in urmatoarea linie de cod din contextul global JS adaugam label-ul `futureData` care va primi ca valoare rezultatul obtinut din invocarea functiei de fațadă `fetch`:
[Screencap 3]: https://i.imgur.com/VvtuVPX.png "thread de executie global JS"
![alt text][Screencap 3]
spre deosebire de setTimeout, functia de fațadă fetch se va manifesta pe doua directii: in exteriorul JS si in interiorul JS. in interior va primi un obiect Promise cu o proprietate value si alta onFulfillment. obiectul va fi returnat in label-ul futureData:
[Screencap 4]: https://i.imgur.com/EjxhJIP.png "mem globala js"
![alt text][Screencap 4]
la fel ca in exemplul precedent cu `fetch`, pe partea din afara JS va fi setat un request `XHR` in background-ul web API-ului, iar data returnata va fi setata in proprietatea `value` din `futureData`:
[Screencap 5]: https://i.imgur.com/sQtz7Mk.png "context de executie XHR"
![alt text][Screencap 5]
4. continuam cu urmatoarea linie de cod din JS `futureData.then(display)` care va situa definitia functiei `display` in array-ul din proprietatea `onFulfillment` aflata acum in obiectul `futureData`
[Screencap 6]: https://i.imgur.com/wsyxsgL.png "thread de executie global JS"
![alt text][Screencap 6]
5. urmatoarea linie de cod din JS va invoca functia `blockFor10ms()` care blocheaza thread-ul JS timp de 300ms:
[Screencap 7]: https://i.imgur.com/dyJKf4Q.png "thread de executie global JS"
![alt text][Screencap 7]
In timp ce `blockFor300ms` se afla pe call stack, sa presupunem ca am primit inapoi requestul de la youtube/server in background-ul web API-ului `XHR`:
[Screencap 8]: https://i.imgur.com/uEwQPGA.png "context de executie XHR"
![alt text][Screencap 8]
data returnata din request va fi stocata in proprietatea `value` din obiectul futureData ceea ce va duce la invocarea functiei display cu inputul din `value`:
[Screencap 9]: https://i.imgur.com/WDx1vTH.png "mem globala JS"
![alt text][Screencap 9]
Asadar, in acest moment functia `display` e pregatita sa fie apelata, insa nu putem face asta pentru ca in call stack inca se mai afla functia `blockFor300ms`. In acest caz, unde plasam `display` sa astepte pana cand JS e gata sa ruleze functia? Tot in `callback queue` alaturi de `printHello`?

> JavaScript are un loc de asteptare aditional numit `microtask queue` unde sunt puse sa astepte toate functiile de fațadă care returneaza obiectul `Promise` in JS si declanseaza rularea automata a unor functii puse intr-o proprietate din `Promise`. Functiile din `microtask queue` au prioritate fata de cele din `callback queue` si vor fi puse pe call stack inaintea lor:
>
[Screencap 10]: https://i.imgur.com/xUz3Pnl.png "event loop"
![alt text][Screencap 10]

6. sa presupunem ca au trecut cele 300ms si functia blockFor300ms() a fost inlaturata de pe call stack. asta inseamna ca putem continua cu urmatoarea linie de cod globala:
[Screencap 11]: https://i.imgur.com/vPluACe.png "mem globala"
![alt text][Screencap 11]

7. Acum call stack-ul e gol si codul din contextul global a fost executat in mod sincron, de sus in jos. In acest moment `event loop` se uita intai in `microtask queue` sa vada daca sunt functii in asteptare si gaseste display pe care o pune pe `call stack`:
[Screencap 12]: https://i.imgur.com/w27xLqJ.png "call stack & mem globala JS"
![alt text][Screencap 12]

8. `callstack queue` si `microtask queue` sunt goale si `Event loop` se uita in callback queue sa vada daca se afla acolo vreo functie pe care sa o puna pe callstack queue. In final gaseste functia `printHello`, care a asteptat la coada inca din primele ms, si o pune pe callstack:
[Screencap 13]: https://i.imgur.com/aXuYa0E.png "call stack & mem globala JS"
![alt text][Screencap 13]

### Catching errors

Ce se intampla daca `fetch()` intampina probleme in timp ce lucreaza in background-ul din browser, incercand sa se conecteze la un server? 

Proprietatea `status` va avea valoarea `rejected`. in acest caz, atunci un alt array `onRejection` va rula automat functiile puse in acest `array`. Putem pune functii in `onRejection` cu ajutorul metodei `.catch`, in cazul nostru putem scrie `futureData.catch(displayError)` si o eventuala functie `displayError` va ajunge in `array-ul` `onRejection`, fiind invocata atunci cand avem `status: rejected` in obiectul `futureData`:

[Screencap 14]: https://i.imgur.com/5fs7jFY.png "obiect futureData"
![alt text][Screencap 14]
